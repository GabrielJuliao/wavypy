<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Waveform Viewer</title>
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline';"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background: #1a1a1a;
        color: #e0e0e0;
      }

      .container {
        max-width: 100%;
        margin: 0 auto;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      h1 {
        color: #e0e0e0;
        margin-top: 0;
      }

      .controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .controls button {
        background-color: #2c6e31;
        border: none;
        color: white;
        padding: 8px 16px;
        text-align: center;
        text-decoration: none;
        font-size: 14px;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.3s;
      }

      .controls button:hover {
        background-color: #3c9341;
      }

      .controls button:disabled {
        background-color: #444444;
        color: #888888;
        cursor: not-allowed;
      }

      .band-display-mode {
        margin-left: auto;
        background-color: #333333;
        color: #e0e0e0;
      }

      .scroll-container {
        width: 100%;
        margin-top: 10px;
      }

      .scroll-bar {
        width: 100%;
        height: 20px;
        background-color: #333333;
        border: 1px solid #555555;
      }

      .waveform-container {
        position: relative;
        width: 100%;
        height: 300px;
        background-color: #333333;
        border: 1px solid #555555;
        overflow: hidden;
        border-radius: 4px;
      }

      canvas {
        display: block;
      }

      #time-info {
        margin-top: 10px;
        font-size: 14px;
        color: #aaaaaa;
      }

      .file-input {
        margin-bottom: 20px;
        color: #e0e0e0;
      }

      .file-input input[type="file"] {
        background-color: #333333;
        color: #e0e0e0;
        border: 1px solid #555555;
        padding: 5px;
        border-radius: 4px;
      }

      #loading {
        display: none;
        margin-left: 10px;
        color: #aaaaaa;
      }

      .zoom-level {
        margin-left: 10px;
        color: #aaaaaa;
      }

      .band-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
        margin-bottom: 15px;
      }

      .band-checkbox {
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
        border-radius: 4px;
        background-color: #333333;
        transition: background-color 0.2s;
        color: #e0e0e0;
      }

      .band-checkbox input {
        margin-right: 5px;
      }

      .band-checkbox:hover {
        background-color: #444444;
      }

      .color-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-left: 5px;
        border: 1px solid #666666;
      }

      .info-panel {
        margin-top: 15px;
        padding: 10px;
        background-color: #2a2a2a;
        border-radius: 4px;
        font-size: 14px;
        color: #ccc;
        border: 1px solid #444444;
      }

      select {
        background-color: #333333;
        color: #e0e0e0;
        border: 1px solid #555555;
        padding: 5px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Waveform Viewer</h1>

      <div class="file-input">
        <label for="file-input">Upload JSON waveform data: </label>
        <input type="file" id="file-input" accept=".json" />
        <span id="loading">Loading...</span>
      </div>

      <div class="info-panel" id="file-info">
        Upload a waveform JSON file to see information.
      </div>

      <div class="band-display-mode">
        <label for="display-mode">Display Mode: </label>
        <select id="display-mode">
          <option value="stacked">Stacked (Each band separately)</option>
          <option value="overlay">Overlay (All bands together)</option>
        </select>
      </div>

      <div class="band-checkboxes" id="band-checkboxes">
        <!-- Band checkboxes will be inserted here dynamically -->
      </div>

      <div class="controls">
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <span class="zoom-level">Zoom: <span id="zoom-value">1x</span></span>
      </div>

      <div class="waveform-container">
        <canvas id="waveform"></canvas>
      </div>

      <div id="time-info">Duration: 0.00 seconds | View: 0.00s - 0.00s</div>

      <div class="scroll-container">
        <input
          type="range"
          id="scroll-bar"
          class="scroll-bar"
          min="0"
          max="100"
          value="0"
          disabled
        />
      </div>
    </div>
    <script>
      class WaveformRenderer {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.waveformData = null;
          this.zoom = 1;
          this.offset = 0;
          this.selectedBands = new Set();
          this.displayMode = "stacked"; // 'stacked' or 'overlay'

          // Predefined colors for bands
          this.bandColors = {
            low: "#0055e2", // blue
            mid: "#f2aa3c", // orange
            high: "#ffffff", // white
          };

          this.colors = {
            background: "#000000",
            centerLine: "#cccccc",
          };

          this.resizeCanvas();
          window.addEventListener("resize", () => this.resizeCanvas());
        }

        resizeCanvas() {
          const container = this.canvas.parentElement;
          this.canvas.width = container.clientWidth;
          this.canvas.height = container.clientHeight;
          this.render();
        }

        async loadData(data) {
          console.log("Loading waveform data:", data);
          this.waveformData = data;

          // Decode all band samples
          for (const band of this.waveformData.data.multiband.bands) {
            band.samples = await this.decodeSamples(
              band.samples,
              band.sample_format,
              band.compression,
              this.waveformData.bits_per_sample
            );
          }

          // Initialize selected bands
          const bandNames = this.waveformData.data.multiband.bands.map(
            (b) => b.name
          );
          this.selectedBands = new Set(bandNames);

          this.createBandCheckboxes();
          this.updateFileInfo();
          this.render();
          this.updateTimeInfo();
          this.enableControls();
          this.updateScrollBar();
        }

        async decodeSamples(samples, sampleFormat, compression, bits) {
          // Decode base64 string
          const binaryString = atob(samples);
          const byteArray = new Uint8Array(
            [...binaryString].map((ch) => ch.charCodeAt(0))
          );

          // Handle sample format
          const dataView = new DataView(byteArray.buffer);
          const sampleCount = byteArray.length / (bits === 8 ? 1 : 2);
          const samplesArray = new Int16Array(sampleCount);

          for (let i = 0; i < sampleCount; i++) {
            if (bits === 8) {
              samplesArray[i] = dataView.getInt8(i) * 256;
            } else {
              samplesArray[i] = dataView.getInt16(i * 2, true);
            }
          }

          return Array.from(samplesArray);
        }

        createBandCheckboxes() {
          const container = document.getElementById("band-checkboxes");
          container.innerHTML = "";

          if (!this.waveformData) return;

          this.waveformData.data.multiband.bands.forEach((band) => {
            const color = this.bandColors[band.name] || "#ffffff";
            const checkbox = document.createElement("label");
            checkbox.className = "band-checkbox";

            const input = document.createElement("input");
            input.type = "checkbox";
            input.checked = this.selectedBands.has(band.name);
            input.dataset.band = band.name;
            input.addEventListener("change", () => {
              this.selectedBands[input.checked ? "add" : "delete"](band.name);
              this.render();
            });

            const colorIndicator = document.createElement("span");
            colorIndicator.className = "color-indicator";
            colorIndicator.style.backgroundColor = color;

            checkbox.appendChild(input);
            checkbox.appendChild(document.createTextNode(band.name));
            checkbox.appendChild(colorIndicator);
            container.appendChild(checkbox);
          });
        }

        updateFileInfo() {
          if (!this.waveformData) return;

          const infoPanel = document.getElementById("file-info");
          const {
            channels,
            sample_rate,
            bits_per_sample,
            samples_per_pixel,
            duration,
            version,
            metadata,
          } = this.waveformData;

          const bands = this.waveformData.data.multiband.bands
            .map((b) => b.name)
            .join(", ");

          infoPanel.innerHTML = `
            <strong>File Info:</strong>
            Sample Rate: ${sample_rate}Hz |
            Channels: ${channels} |
            Resolution: ${bits_per_sample}bit |
            Samples per Pixel: ${samples_per_pixel} |
            Duration: ${duration.toFixed(2)}s |
            Version: ${version} |
            Type: multiband |
            Bands: ${bands} |
            ${
              metadata.compression ? `Compression: ${metadata.compression}` : ""
            }
          `;
        }

        zoomIn() {
          if (this.zoom < 10) {
            const centerOffset = this.offset + this.getVisibleWidth() / 2;
            this.zoom *= 1.5;
            this.offset = centerOffset - this.getVisibleWidth() / 2;
            this.clampOffset();
            this.render();
            this.updateTimeInfo();
            this.updateZoomLabel();
            this.updateScrollBar();
          }
        }

        zoomOut() {
          if (this.zoom > 0.1) {
            const centerOffset = this.offset + this.getVisibleWidth() / 2;
            this.zoom /= 1.5;
            this.offset = centerOffset - this.getVisibleWidth() / 2;
            this.clampOffset();
            this.render();
            this.updateTimeInfo();
            this.updateZoomLabel();
            this.updateScrollBar();
          }
        }

        clampOffset() {
          const maxOffset = Math.max(
            0,
            this.getFullWidth() - this.getVisibleWidth()
          );
          this.offset = Math.min(Math.max(0, this.offset), maxOffset);
        }

        getVisibleWidth() {
          return this.canvas.width / this.zoom;
        }

        getFullWidth() {
          if (!this.waveformData) return 0;
          const band = this.waveformData.data.multiband.bands[0];
          return band.samples.length / 2; // Each point has min and max
        }

        render() {
          if (!this.waveformData) {
            this.renderEmptyState();
            return;
          }

          const { width, height } = this.canvas;
          this.ctx.fillStyle = this.colors.background;
          this.ctx.fillRect(0, 0, width, height);

          const selectedBands = Array.from(this.selectedBands);
          if (selectedBands.length === 0) {
            this.renderEmptyState("No bands selected.");
            return;
          }

          this.displayMode === "stacked"
            ? this.renderStackedBands(selectedBands, width, height)
            : this.renderOverlayBands(selectedBands, width, height);
        }

        renderStackedBands(selectedBands, width, height) {
          const bandHeight = height / selectedBands.length;

          selectedBands.forEach((bandName, index) => {
            const bandTop = index * bandHeight;
            const bandCenterY = bandTop + bandHeight / 2;

            // Draw center line
            this.ctx.beginPath();
            this.ctx.moveTo(0, bandCenterY);
            this.ctx.lineTo(width, bandCenterY);
            this.ctx.strokeStyle = this.colors.centerLine;
            this.ctx.stroke();

            const bandColor = this.bandColors[bandName] || "#ffffff";
            this.renderBandWaveform(
              bandName,
              bandTop,
              bandHeight,
              bandCenterY,
              bandColor
            );

            // Draw band name
            this.ctx.fillStyle = "#333";
            this.ctx.font = "12px Arial";
            this.ctx.fillText(bandName, 5, bandTop + 15);
          });
        }

        renderOverlayBands(selectedBands, width, height) {
          const centerY = height / 2;

          // Draw center line
          this.ctx.beginPath();
          this.ctx.moveTo(0, centerY);
          this.ctx.lineTo(width, centerY);
          this.ctx.strokeStyle = this.colors.centerLine;
          this.ctx.stroke();

          // Define band rendering order
          const renderOrder = ["low", "mid", "high"];

          // Sort the bands based on render order
          const orderedBands = [...selectedBands].sort((a, b) => {
            const indexA = renderOrder.indexOf(a);
            const indexB = renderOrder.indexOf(b);
            return (
              (indexA === -1 ? 999 : indexA) - (indexB === -1 ? 999 : indexB)
            );
          });

          // Render bands in the correct order
          orderedBands.forEach((bandName) => {
            const bandColor = this.bandColors[bandName] || "#ffffff";
            this.renderBandWaveform(
              bandName,
              0,
              height,
              centerY,
              bandColor,
              bandName
            );
          });

          // Draw band names
          this.ctx.font = "12px Arial";
          orderedBands.forEach((bandName, index) => {
            const bandColor = this.bandColors[bandName] || "#ffffff";
            this.ctx.fillStyle = bandColor;
            this.ctx.fillText(bandName, 5 + index * 60, 15);
          });
        }

        renderBandWaveform(
          bandName,
          bandTop,
          bandHeight,
          centerY,
          color,
          bandNameForOverlay
        ) {
          const band = this.waveformData.data.multiband.bands.find(
            (b) => b.name === bandName
          );

          if (!band) return;

          const samples = band.samples;
          const visibleStart = Math.floor(this.offset);
          const visibleEnd = Math.min(
            Math.ceil(this.offset + this.getVisibleWidth()),
            samples.length / 2
          );

          // Render using club style
          this.renderClubStyle(
            samples,
            visibleStart,
            visibleEnd,
            bandHeight,
            centerY,
            color,
            bandNameForOverlay
          );
        }

        renderClubStyle(
          samples,
          visibleStart,
          visibleEnd,
          height,
          centerY,
          color,
          bandName
        ) {
          const ctx = this.ctx;
          const scaleFactor = (height / 2) * 0.8;

          // Apply appropriate blending mode in overlay mode
          if (this.displayMode === "overlay") {
            if (bandName === "low") {
              ctx.globalCompositeOperation = "source-over"; // Base layer
            } else if (bandName === "mid") {
              ctx.globalCompositeOperation = "lighten"; // To blend with low
            } else {
              ctx.globalCompositeOperation = "source-over"; // Default
            }

            // Set transparency based on band
            if (bandName === "high") {
              ctx.globalAlpha = 0.9;
            } else if (bandName === "low") {
              ctx.globalAlpha = 0.8;
            } else if (bandName === "mid") {
              ctx.globalAlpha = 0.7;
            } else {
              ctx.globalAlpha = 0.8; // Default
            }
          }

          // Draw filled waveform
          ctx.beginPath();
          ctx.moveTo((visibleStart - this.offset) * this.zoom, centerY);

          // Upper waveform
          for (let i = visibleStart; i < visibleEnd; i++) {
            const x = (i - this.offset) * this.zoom;
            const maxY = samples[i * 2 + 1]; // Raw upper peak
            const yMax = centerY - (maxY / 32768) * scaleFactor;
            ctx.lineTo(x, yMax);
          }

          // Complete the path back to center
          const lastX = (visibleEnd - 1 - this.offset) * this.zoom;
          ctx.lineTo(lastX, centerY);

          // Lower waveform (in reverse)
          for (let i = visibleEnd - 1; i >= visibleStart; i--) {
            const x = (i - this.offset) * this.zoom;
            const minY = samples[i * 2]; // Raw lower peak
            const yMin = centerY - (minY / 32768) * scaleFactor;
            ctx.lineTo(x, yMin);
          }

          // Close the path
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();

          // Add outline with slight glow
          ctx.lineWidth = 1;
          ctx.strokeStyle = color;
          ctx.stroke();

          // Special effect for high frequencies in overlay mode
          if (
            this.displayMode === "overlay" &&
            (bandName === "high")
          ) {
            ctx.shadowColor = "#ffffff";
            ctx.shadowBlur = 4;
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = "#ffffff";
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Reset canvas properties
          ctx.globalCompositeOperation = "source-over";
          ctx.globalAlpha = 1.0;
        }

        renderEmptyState(message = "Upload a waveform JSON file to visualize") {
          const { width, height } = this.canvas;
          this.ctx.fillStyle = this.colors.background;
          this.ctx.fillRect(0, 0, width, height);
          this.ctx.fillStyle = "#666";
          this.ctx.font = "14px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText(message, width / 2, height / 2);
        }

        updateTimeInfo() {
          if (!this.waveformData) return;

          const { samples_per_pixel, sample_rate } = this.waveformData;
          const totalPoints = this.getFullWidth();
          const totalDuration = (totalPoints * samples_per_pixel) / sample_rate;
          const startTime = (this.offset * samples_per_pixel) / sample_rate;
          const endTime = Math.min(
            totalDuration,
            ((this.offset + this.getVisibleWidth()) * samples_per_pixel) /
              sample_rate
          );

          document.getElementById(
            "time-info"
          ).textContent = `Duration: ${totalDuration.toFixed(
            2
          )}s | View: ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s`;
        }

        updateZoomLabel() {
          document.getElementById(
            "zoom-value"
          ).textContent = `${this.zoom.toFixed(1)}x`;
        }

        enableControls() {
          ["zoom-in", "zoom-out", "scroll-bar", "display-mode"].forEach(
            (id) => (document.getElementById(id).disabled = false)
          );
        }

        updateScrollBar() {
          const scrollBar = document.getElementById("scroll-bar");
          if (!this.waveformData) return;

          const totalWidth = this.getFullWidth();
          const visibleWidth = this.getVisibleWidth();
          scrollBar.max = Math.max(0, totalWidth - visibleWidth);
          scrollBar.value = this.offset;
          scrollBar.disabled = totalWidth <= visibleWidth;
        }

        setDisplayMode(mode) {
          this.displayMode = mode;
          this.render();
        }
      }

      document.addEventListener("DOMContentLoaded", function () {
        const renderer = new WaveformRenderer("waveform");

        document
          .getElementById("zoom-in")
          .addEventListener("click", () => renderer.zoomIn());
        document
          .getElementById("zoom-out")
          .addEventListener("click", () => renderer.zoomOut());
        document.getElementById("scroll-bar").addEventListener("input", (e) => {
          renderer.offset = parseFloat(e.target.value);
          renderer.render();
          renderer.updateTimeInfo();
        });
        document
          .getElementById("display-mode")
          .addEventListener("change", (e) => {
            renderer.setDisplayMode(e.target.value);
          });

        document
          .getElementById("file-input")
          .addEventListener("change", async function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const loading = document.getElementById("loading");
            loading.style.display = "inline";

            try {
              const text = await file.text();
              const jsonData = JSON.parse(text);

              // Check if it's a multiband waveform
              if (jsonData.type !== "multiband") {
                throw new Error("Only multiband waveforms are supported");
              }

              await renderer.loadData(jsonData);
            } catch (err) {
              console.error("Error processing file:", err);
              alert("Error loading waveform file: " + err.message);
            } finally {
              loading.style.display = "none";
            }
          });
      });
    </script>
  </body>
</html>
