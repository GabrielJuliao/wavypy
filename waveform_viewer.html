<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waveform Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button, .controls select {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .controls button:hover, .controls select:hover {
            background-color: #45a049;
        }
        .controls button:disabled, .controls select:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .style-selector {
            margin-left: auto;
        }
        .scroll-container {
            width: 100%;
            margin-top: 10px;
        }
        .scroll-bar {
            width: 100%;
            height: 20px;
        }
        .waveform-container {
            position: relative;
            width: 100%;
            height: 300px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            overflow: hidden;
            border-radius: 4px;
        }
        canvas {
            display: block;
        }
        #time-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        .file-input {
            margin-bottom: 20px;
        }
        #loading {
            display: none;
            margin-left: 10px;
            color: #666;
        }
        .zoom-level {
            margin-left: 10px;
            color: #666;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Waveform Viewer</h1>

    <div class="file-input">
        <label for="file-input">Upload JSON waveform data: </label>
        <input type="file" id="file-input" accept=".json">
        <span id="loading">Loading...</span>
    </div>

    <div class="controls">
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <span class="zoom-level">Zoom: <span id="zoom-value">1x</span></span>

        <div class="style-selector">
            <select id="waveform-style">
                <option value="line">Line Style</option>
                <option value="solid">Solid Style</option>
                <option value="bars">Bar Style</option>
                <option value="points">Point Style</option>
            </select>
        </div>
    </div>

    <div class="waveform-container">
        <canvas id="waveform"></canvas>
    </div>

    <div id="time-info">
        Duration: 0.00 seconds | View: 0.00s - 0.00s
    </div>

    <div class="scroll-container">
        <input type="range" id="scroll-bar" class="scroll-bar" min="0" max="100" value="0" disabled>
    </div>
</div>

<script>
    class WaveformRenderer {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.waveformData = null;
            this.zoom = 1;
            this.offset = 0;
            this.colors = {
                background: '#f9f9f9',
                waveform: '#4CAF50',
                centerLine: '#cccccc'
            };
            this.renderStyle = 'line'; // Default render style

            this.resizeCanvas();

            window.addEventListener('resize', () => this.resizeCanvas());
        }

        resizeCanvas() {
            const container = this.canvas.parentElement;
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            this.render();
        }

        loadData(data) {
            console.log("Loading data into renderer:", data);
            this.waveformData = data;
            this.zoom = 1;
            this.offset = 0;

            // Log important properties
            console.log("Data length:", data.data.length);
            console.log("Channels:", data.channels);
            console.log("Sample rate:", data.sample_rate);
            console.log("Samples per pixel:", data.samples_per_pixel);

            // Render the data
            this.render();
            this.updateTimeInfo();
            this.enableControls();
            this.updateScrollBar();
        }

        zoomIn() {
            if (this.zoom < 10) {
                const centerOffset = this.offset + (this.getVisibleWidth() / 2);
                this.zoom *= 1.5;
                this.offset = centerOffset - (this.getVisibleWidth() / 2);
                this.clampOffset();
                this.render();
                this.updateTimeInfo();
                this.updateZoomLabel();
                this.updateScrollBar();
            }
        }

        zoomOut() {
            if (this.zoom > 0.1) {
                const centerOffset = this.offset + (this.getVisibleWidth() / 2);
                this.zoom /= 1.5;
                this.offset = centerOffset - (this.getVisibleWidth() / 2);
                this.clampOffset();
                this.render();
                this.updateTimeInfo();
                this.updateZoomLabel();
                this.updateScrollBar();
            }
        }

        clampOffset() {
            const maxOffset = Math.max(0, this.getFullWidth() - this.getVisibleWidth());
            this.offset = Math.min(Math.max(0, this.offset), maxOffset);
        }

        getVisibleWidth() {
            return this.canvas.width / this.zoom;
        }

        getFullWidth() {
            if (!this.waveformData || !this.waveformData.data) return 0;
            return this.waveformData.length || this.waveformData.data.length / 2;
        }

        render() {
            console.log("Rendering waveform...");

            if (!this.waveformData || !this.waveformData.data) {
                console.log("No waveform data to render");
                this.renderEmptyState();
                return;
            }

            console.log("Waveform data available, rendering...");
            const { width, height } = this.canvas;
            const centerY = height / 2;

            // Clear canvas
            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(0, 0, width, height);

            // Draw center line
            this.ctx.beginPath();
            this.ctx.moveTo(0, centerY);
            this.ctx.lineTo(width, centerY);
            this.ctx.strokeStyle = this.colors.centerLine;
            this.ctx.stroke();

            // Calculate visible range
            const visibleStart = Math.floor(this.offset);
            const visibleEnd = Math.min(
                Math.ceil(this.offset + this.getVisibleWidth()),
                this.getFullWidth()
            );

            console.log(`Rendering points from ${visibleStart} to ${visibleEnd}`);

            // Choose the appropriate rendering method based on the style
            switch (this.renderStyle) {
                case 'solid':
                    this.renderSolidStyle(visibleStart, visibleEnd, width, height, centerY);
                    break;
                case 'bars':
                    this.renderBarStyle(visibleStart, visibleEnd, width, height, centerY);
                    break;
                case 'points':
                    this.renderPointStyle(visibleStart, visibleEnd, width, height, centerY);
                    break;
                case 'line':
                default:
                    this.renderLineStyle(visibleStart, visibleEnd, width, height, centerY);
                    break;
            }
        }

        renderLineStyle(visibleStart, visibleEnd, width, height, centerY) {
            // Draw waveform as connected lines between min/max points
            this.ctx.beginPath();
            let pointsDrawn = 0;

            for (let i = visibleStart; i < visibleEnd; i++) {
                if (i < 0 || i >= this.getFullWidth()) continue;

                const data = this.waveformData.data;
                const channels = this.waveformData.channels || 1;

                // Calculate the x-coordinate on the canvas
                const x = (i - this.offset) * this.zoom;

                // Direct access to the data - our format is just [min1, max1, min2, max2, ...]
                const pointIndex = i * 2;  // Each point has min and max

                if (pointIndex + 1 >= data.length) {
                    continue; // Skip if data is out of bounds
                }

                const minY = data[pointIndex];      // min value
                const maxY = data[pointIndex + 1];  // max value

                // Normalize values to the canvas height
                const scaleFactor = (height / 2) * 0.8; // 80% of half height for better visibility

                // Convert to y-coordinates (invert because canvas y increases downward)
                const yMin = centerY - (minY / 32768) * scaleFactor;
                const yMax = centerY - (maxY / 32768) * scaleFactor;

                // Draw vertical line for this point
                this.ctx.moveTo(x, yMin);
                this.ctx.lineTo(x, yMax);

                pointsDrawn++;
            }

            this.ctx.strokeStyle = this.colors.waveform;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();

            console.log(`Drew ${pointsDrawn} points on canvas (line style)`);
        }

        renderSolidStyle(visibleStart, visibleEnd, width, height, centerY) {
            // Draw waveform as a filled shape
            this.ctx.beginPath();
            let pointsDrawn = 0;

            // Start at the center line
            this.ctx.moveTo((visibleStart - this.offset) * this.zoom, centerY);

            // Draw the top edge (max values)
            for (let i = visibleStart; i < visibleEnd; i++) {
                if (i < 0 || i >= this.getFullWidth()) continue;

                const data = this.waveformData.data;
                const pointIndex = i * 2;

                if (pointIndex + 1 >= data.length) continue;

                const maxY = data[pointIndex + 1];  // max value
                const x = (i - this.offset) * this.zoom;
                const scaleFactor = (height / 2) * 0.8;
                const y = centerY - (maxY / 32768) * scaleFactor;

                this.ctx.lineTo(x, y);
                pointsDrawn++;
            }

            // Draw the bottom edge (min values) in reverse
            for (let i = visibleEnd - 1; i >= visibleStart; i--) {
                if (i < 0 || i >= this.getFullWidth()) continue;

                const data = this.waveformData.data;
                const pointIndex = i * 2;

                if (pointIndex >= data.length) continue;

                const minY = data[pointIndex];  // min value
                const x = (i - this.offset) * this.zoom;
                const scaleFactor = (height / 2) * 0.8;
                const y = centerY - (minY / 32768) * scaleFactor;

                this.ctx.lineTo(x, y);
                pointsDrawn++;
            }

            // Close the path back to the start
            this.ctx.closePath();

            // Fill the shape
            this.ctx.fillStyle = this.colors.waveform;
            this.ctx.globalAlpha = 0.5;  // Semi-transparent
            this.ctx.fill();
            this.ctx.globalAlpha = 1.0;  // Reset alpha

            console.log(`Drew ${pointsDrawn} points on canvas (solid style)`);
        }

        renderBarStyle(visibleStart, visibleEnd, width, height, centerY) {
            // Draw waveform as bars
            let pointsDrawn = 0;
            const barWidth = Math.max(2, Math.floor(this.zoom - 1));  // Adjust bar width based on zoom

            this.ctx.fillStyle = this.colors.waveform;

            for (let i = visibleStart; i < visibleEnd; i++) {
                if (i < 0 || i >= this.getFullWidth()) continue;

                const data = this.waveformData.data;
                const pointIndex = i * 2;

                if (pointIndex + 1 >= data.length) continue;

                const minY = data[pointIndex];      // min value
                const maxY = data[pointIndex + 1];  // max value

                const x = (i - this.offset) * this.zoom;
                const scaleFactor = (height / 2) * 0.8;

                const yMin = centerY - (minY / 32768) * scaleFactor;
                const yMax = centerY - (maxY / 32768) * scaleFactor;

                // Draw a rectangle for this bar
                this.ctx.fillRect(
                    x - barWidth/2,  // center the bar on the x-coordinate
                    yMax,           // top of the bar (max value)
                    barWidth,       // width of the bar
                    yMin - yMax     // height of the bar
                );

                pointsDrawn++;
            }

            console.log(`Drew ${pointsDrawn} points on canvas (bar style)`);
        }

        renderPointStyle(visibleStart, visibleEnd, width, height, centerY) {
            // Draw waveform as points
            let pointsDrawn = 0;
            const pointRadius = Math.max(2, Math.floor(this.zoom / 2));  // Adjust point size based on zoom

            this.ctx.fillStyle = this.colors.waveform;

            for (let i = visibleStart; i < visibleEnd; i++) {
                if (i < 0 || i >= this.getFullWidth()) continue;

                const data = this.waveformData.data;
                const pointIndex = i * 2;

                if (pointIndex + 1 >= data.length) continue;

                const minY = data[pointIndex];      // min value
                const maxY = data[pointIndex + 1];  // max value

                const x = (i - this.offset) * this.zoom;
                const scaleFactor = (height / 2) * 0.8;

                const yMin = centerY - (minY / 32768) * scaleFactor;
                const yMax = centerY - (maxY / 32768) * scaleFactor;

                // Draw points at min and max
                this.ctx.beginPath();
                this.ctx.arc(x, yMin, pointRadius, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.beginPath();
                this.ctx.arc(x, yMax, pointRadius, 0, Math.PI * 2);
                this.ctx.fill();

                pointsDrawn += 2;  // Count both min and max points
            }

            console.log(`Drew ${pointsDrawn} points on canvas (point style)`);
        }

        renderEmptyState() {
            const { width, height } = this.canvas;

            // Clear canvas
            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(0, 0, width, height);

            // Draw message
            this.ctx.fillStyle = '#666';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('Upload a waveform JSON file to visualize', width / 2, height / 2);
        }

        updateTimeInfo() {
            if (!this.waveformData || !this.waveformData.data) return;

            const samplesPerPixel = this.waveformData.samples_per_pixel || 256; // Default if not provided
            const sampleRate = this.waveformData.sample_rate || 44100; // Default if not provided

            const totalPoints = this.getFullWidth();
            const totalDuration = (totalPoints * samplesPerPixel) / sampleRate;
            const startTime = (this.offset * samplesPerPixel) / sampleRate;
            const endTime = ((this.offset + this.getVisibleWidth()) * samplesPerPixel) / sampleRate;

            document.getElementById('time-info').textContent =
                `Duration: ${totalDuration.toFixed(2)} seconds | View: ${startTime.toFixed(2)}s - ${Math.min(endTime, totalDuration).toFixed(2)}s`;
        }

        updateZoomLabel() {
            document.getElementById('zoom-value').textContent = `${this.zoom.toFixed(1)}x`;
        }

        enableControls() {
            document.getElementById('zoom-in').disabled = false;
            document.getElementById('zoom-out').disabled = false;
            document.getElementById('scroll-bar').disabled = false;
            document.getElementById('waveform-style').disabled = false;
        }

        updateScrollBar() {
            const scrollBar = document.getElementById('scroll-bar');
            if (!this.waveformData) return;

            const totalWidth = this.getFullWidth();
            const visibleWidth = this.getVisibleWidth();

            // Update range
            scrollBar.max = Math.max(0, totalWidth - visibleWidth);
            scrollBar.value = this.offset;

            // Disable scrollbar if everything is visible
            scrollBar.disabled = totalWidth <= visibleWidth;
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        const renderer = new WaveformRenderer('waveform');

        // Initialize with disabled controls
        document.getElementById('zoom-in').disabled = true;
        document.getElementById('zoom-out').disabled = true;
        document.getElementById('scroll-bar').disabled = true;
        document.getElementById('waveform-style').disabled = true;

        // Attach event listeners
        document.getElementById('zoom-in').addEventListener('click', () => renderer.zoomIn());
        document.getElementById('zoom-out').addEventListener('click', () => renderer.zoomOut());
        document.getElementById('scroll-bar').addEventListener('input', (e) => {
            renderer.offset = parseFloat(e.target.value);
            renderer.render();
            renderer.updateTimeInfo();
        });

        document.getElementById('waveform-style').addEventListener('change', (e) => {
            renderer.renderStyle = e.target.value;
            renderer.render();
        });

        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const loading = document.getElementById('loading');
            loading.style.display = 'inline';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    console.log("Loaded JSON data:", jsonData);

                    const waveformData = {
                        length: jsonData.length,
                        data: jsonData.data,
                        channels: jsonData.channels,
                        samples_per_pixel: jsonData.samples_per_pixel,
                        sample_rate: jsonData.sample_rate,
                        bits: jsonData.bits
                    };

                    console.log("Processed waveform data:", waveformData);

                    if (!waveformData.data || waveformData.data.length === 0) {
                        alert('Error: No waveform data found in the file');
                        loading.style.display = 'none';
                        return;
                    }

                    renderer.loadData(waveformData);
                } catch (err) {
                    console.error("JSON parsing error:", err);
                    alert('Error parsing JSON file: ' + err.message);
                } finally {
                    loading.style.display = 'none';
                }
            };
            reader.onerror = function() {
                alert('Error reading file');
                loading.style.display = 'none';
            };
            reader.readAsText(file);
        });
    });
</script>
</body>
</html>